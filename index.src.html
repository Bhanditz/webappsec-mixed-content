<h1>Mixed Content</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec/specs/mixedcontent/
Shortname: MIX
Level: 1
Editor: Mike West, Google Inc., mkwst@google.com
Group: webappsec
Abstract: This specification describes how and why user agents disallow rendering and execution of content loaded over unencrypted or unauthenticated connections in the context of an encrypted and authenticated document.
Link Defaults: HTML5 (dfn) plugin / browsing context / parent browsing context / nested browsing contexts / top-level browsing context / plugin document / frame / sandboxing flag set / ancestor
Link Defaults: HTML5 (interface) document
Link Defaults: HTML5 (element) audio / iframe / video / source / track / script
Version History: https://github.com/w3c/webappsec/commits/master/specs/mixedcontent/index.src.html
</pre>

<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  When a user successfully loads a resource from example.com over a secure
  channel (HTTPS, for example), the user agent is able to make three assertions
  critical to the user's security and privacy:

  <ul>
    <li>
      The user is communicating with a server that is allowed to claim to be
      <code>example.com</code>, and not one of the many, many servers through
      which her request has hopped. The connection can be
      <strong>authenticated</strong>.
    </li>
    <li>
      The user's communications with <code>example.com</code> cannot be
      trivially eavesdropped upon by middlemen, because the requests she makes
      and the responses she receives are <strong>encrypted</strong>.
    </li>
    <li>
      The user's communications with <code>example.com</code> cannot be
      trivially modified by middlemen, the encryption and authentication
      provide a guarantee of <strong>data integrity</strong>.
    </li>
  </ul>

  Together, these assertions give the user some assurance that
  <code>example.com</code> is the only entity that can read and respond to her
  requests (caveat: without shocking amounts of work) and that the bits she's
  receiving are indeed those that <code>example.com</code> actually sent.

  The strength of these assertions is substantially weakened, however, when
  the encrypted and authenticated resource requests subresources (scripts,
  images, etc) over an insecure channel. Those resource requests result in a
  resource whose status is mixed, as insecure requests are wide open for
  man-in-the-middle attacks. This scenario is unfortunately quite common.

  Regardless of <code>example.com</code>'s own privacy, users' privacy and
  security can be further impacted if a public resource can generate requests
  to private resources on a local network. For example, public resources must
  not be allowed to generate requests to a user's router, or an enterprise's
  internal file server.

  This specification details how user agents can mitigate these risks to
  security and privacy by limiting a resource's ability to inadvertently
  communicate in the clear, or to expose non-public resources to the web at
  large.
  
  Note: Nothing described in this document is really new; everything covered
  here has appeared in one or more user agents over the years: Internet Explorer
  led the way, alerting users to mixed active content since at least version 4.
</section>

<!--
████████  ████████ ████████ ████ ██    ██ ████ ████████ ████  ███████  ██    ██  ██████
██     ██ ██       ██        ██  ███   ██  ██     ██     ██  ██     ██ ███   ██ ██    ██
██     ██ ██       ██        ██  ████  ██  ██     ██     ██  ██     ██ ████  ██ ██
██     ██ ██████   ██████    ██  ██ ██ ██  ██     ██     ██  ██     ██ ██ ██ ██  ██████
██     ██ ██       ██        ██  ██  ████  ██     ██     ██  ██     ██ ██  ████       ██
██     ██ ██       ██        ██  ██   ███  ██     ██     ██  ██     ██ ██   ███ ██    ██
████████  ████████ ██       ████ ██    ██ ████    ██    ████  ███████  ██    ██  ██████
-->
<section>
  <h2 id="terms">Key Concepts and Terminology</h2>

  <h3 id="terms-defined-here">Terms defined by this specification</h3>
  <dl>
    <dt>
      <dfn export local-title="mixed">mixed content</dfn>
    </dt>
    <dd>
      A resource is said to be <strong>mixed content</strong> if either of the
      following conditions holds:

      <ul>
        <li>
          The resource's <a>origin</a> is <a>insecure</a>, <strong>and</strong>
          the <a>JavaScript global environment</a> into which it is loaded is a
          <a>secure context</a>.
        </li>
        <li>
          The resource's <a>origin</a> is <a>private</a> <strong>and</strong>
          the <a>origin</a> of the <a>JavaScript global environment</a> into
          which it is loaded is <a>public</a>.
        </li>
      </ul>

      <div class="example">
        The image <code>http://example.com/image.png</code> is <strong>mixed
        content</strong> when loaded by
        <code>https://not.example.com/</code>.

        The image <code>http://127.0.0.1/image.png</code> is <strong>mixed
        content</strong> when loaded by <code>http://example.com/</code>.
      </div>
    </dd>

    <dt>
      <dfn export local-title="private">private origin</dfn>
    </dt>
    <dd>
      An <a>origin</a> is considered a <strong>private origin</strong> if any
      of the following conditions holds:

      <ul>
        <li>
          The origin's <code>scheme</code> component is <code>file</code>.
        </li>
        <li>
          The origin's <code>host</code> component is <code>localhost</code>,
          or matches one of the CIDR notations <code>127.0.0.0/8</code> or
          <code>::1/128</code> [[!RFC4632]]
        </li>
        <li>
          The origin's <code>host</code> component matches one of the
          <dfn>private address space</dfn> patterns defined in
          <a href="http://tools.ietf.org/html/rfc1918#section-3">Section 3 of
          RFC1918</a> (<code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>,
          <code>192.168.0.0/16</code>) [[!RFC1918]].
        </li>
        <li>
          The origin's <code>host</code> component is an <dfn>Internal
          Name</dfn>, as defined by the CA/Browser Forum's Baseline
          Requirements [[!CAB]].
        </li>
      </ul>
    </dd>

    <dt>
      <dfn export local-title="public">public origin</dfn>
    </dt>
    <dd>
      Any <a>origin</a> which is not <a>private</a> is said to be a
      <strong>public origin</strong>.
    </dd>

    <dt>
      <dfn export local-title="potentially secure">
        potentially secure origin
      </dfn>
    </dt>
    <dd>
      An <a>origin</a> is said to be <strong>potentially secure</strong>
      if one of the following is true:

      <ul>
        <li>
          The origin's scheme component is <code>HTTPS</code>,
          <code>WSS</code>, or <code>about</code>.
        </li>
        <li>
          The origin is a <a>globally unique identifier</a> (for example,
          a <code>blob</code> URL).
        </li>
      </ul>

      Note: The mixed content checks take place <em>after</em> Strict
      Transport Security is applied to resource URLs, which simplifies
      determination of insecurity. [[RFC6797]]
    </dd>

    <dt>
      <dfn export local-title="a priori insecure">
        <em>a priori</em> insecure origin
      </dfn>
    </dt>
    <dd>
      Any <a>origin</a> which is not <a>potentially secure</a> is said to
      be <strong><em>a priori</em> insecure</strong>. We know, for example, that
      <code>http://example.com/</code> is insecure just by looking at its scheme
      component.
    </dd>

    <dt>
      <dfn export local-title="insecure">
        insecure origin
      </dfn>
    </dt>
    <dd>
      An resource's origin is said to be <strong>insecure</strong> if it is
      either <a><em>a priori</em> insecure</a>, or the user agent discovers
      only after performing a TLS-handshake that the TLS-protection offered
      is either <a>weak</a> or <a>deprecated</a>.
    </dd>

    <dt>
      <dfn export local-title="deprecated">
        deprecated TLS-protection
      </dfn>
    </dt>
    <dd>
      A resource's TLS-protection is said to be <strong>deprecated</strong>
      if it is not <a>weakly TLS-protected</a>, but the user agent chooses to
      refuse it anyway. This determination is vendor-specific.

      For example, a user agent may choose to reject resources for which the
      server presented a publicly-trusted certificate for an <a>Internal
      Name</a> (e.g. <code>https://intranet/</code>), a certificate with an
      overly-long validity period, a certificate signed with SHA-1, or a
      certificate which otherwise fails to meet the
      <a href="https://cabforum.org/baseline-requirements-documents/">
      CA/Browser Forum's Baseline Requirements</a>.
    </dd>
  </dl>

  <h3 id="terms-defined-by-reference">Terms defined by reference</h3>
  <dl>
    <dt><dfn>TLS-protected</dfn></dt>
    <dt><dfn local-title="weak">weakly TLS-protected</dfn></dt>
    <dd>
      These terms are defined in
      <a href="http://www.w3.org/TR/2010/REC-wsc-ui-20100812/#typesoftls">§5.2
      of "Web Security Context: User Interface Guidelines"</a> [[!WSC-UI]].
      A resource is <strong>TLS-protected</strong> when it is delivered over an
      encrypted channel. <strong>Weakly TLS-protected</strong> refers to a
      subset of those resources delivered over a channel that doesn't offer
      strong protection of the content.

      For example, resources would be considered weakly TLS-protected when
      delivered by a server presenting a self-signed certificate, as such a
      certificate only weakly authenticates the server. Similarly, a server
      which negotiates down to a weak cipher suite (such as
      <code>TLS_RSA_WITH_NULL_MD5</code>) would only weakly protect resources
      it serves.
    </dd>

    <dt><dfn>origin</dfn></dt>
    <dd>
      An origin defines the scope of authority or privilege under which a
      resource operates. It is defined in detail in the Origin specification.
      [[!RFC6454]]
    </dd>

    <dt><dfn>globally unique identifier</dfn></dt>
    <dd>
      This term is defined in
      <a href="http://tools.ietf.org/html/rfc6454#section-4">Section 4 of
      RFC6454</a>. [[!RFC6454]]
    
      Note: URLs that do not use
      <a href="http://tools.ietf.org/html/rfc3986#section-3.2">hierarchical
      elements</a> as naming authorities (for example: <code>blob:</code>, and
      <code>data:</code>) have origins which are globally unique identifiers.
      [[URI]]
    </dd>

    <dt><dfn>fetch</dfn></dt>
    <dd>
      "fetching" is the process by which a user agent requests resources, and
      delivers responses. It is defined in detail in the Fetch living standard.
      [[!FETCH]]
    </dd>

    <dt><dfn>request</dfn></dt>
    <dt><dfn local-title="client">request client</dfn></dt>
    <dt><dfn local-title="context">request context</dfn></dt>
    <dd>
      These terms are defined in
      <a href="http://fetch.spec.whatwg.org/#requests">Section 2.2</a> of the
      Fetch living standard. [[!FETCH]]
    </dd>

    <dt><dfn>response</dfn></dt>
    <dt><dfn>network error</dfn></dt>
    <dd>
      These terms are defined in detail in
      <a href="http://fetch.spec.whatwg.org/#responses">Section 2.3</a> of the
      Fetch living standard. [[!FETCH]]
    </dd>

    <dt><dfn local-title="global environment">JavaScript global environment</dfn></dt>
    <dd>
      This term is defined in
      <a href="http://www.w3.org/TR/html5/infrastructure.html#javascript-global-environment">Section
      2.2.2 of the HTML5 specification</a>. [[!HTML5]]
    </dd>
  </dl>
</section>

<!--
 ██████   ███████  ██    ██ ████████ ████████ ██    ██ ████████        ██████     ███    ████████ ████████  ██████    ███████  ████████  ████ ████████  ██████
██    ██ ██     ██ ███   ██    ██    ██       ███   ██    ██          ██    ██   ██ ██      ██    ██       ██    ██  ██     ██ ██     ██  ██  ██       ██    ██
██       ██     ██ ████  ██    ██    ██       ████  ██    ██          ██        ██   ██     ██    ██       ██        ██     ██ ██     ██  ██  ██       ██
██       ██     ██ ██ ██ ██    ██    ██████   ██ ██ ██    ██          ██       ██     ██    ██    ██████   ██   ████ ██     ██ ████████   ██  ██████    ██████
██       ██     ██ ██  ████    ██    ██       ██  ████    ██          ██       █████████    ██    ██       ██    ██  ██     ██ ██   ██    ██  ██             ██
██    ██ ██     ██ ██   ███    ██    ██       ██   ███    ██          ██    ██ ██     ██    ██    ██       ██    ██  ██     ██ ██    ██   ██  ██       ██    ██
 ██████   ███████  ██    ██    ██    ████████ ██    ██    ██           ██████  ██     ██    ██    ████████  ██████    ███████  ██     ██ ████ ████████  ██████
-->
<section>
  <h2 id="categories">Categories of Content</h2>

  Categories of content are defined informally directly below. Note that the
  lists in the following three sections attempt to be comprehensive, but the
  platform is huge: in practice, user agents will determine a resource's
  category based on it's <a>request context</a>, which is much simpler to
  exhaustively define.

  Fetch defines three <a>request contexts</a> that do not map directly to
  resources which are included in a <a>global environment</a>:<code>form</code>,
  <code>navigate</code>, and <code>popup</code>. These contexts are
  <dfn export>navigational request contexts</dfn>, and cover navigations between
  pages, not content. User agents MAY treat one or more of these contexts as
  either <a>active</a> or <a>blockable passive</a> content if they choose to do
  so: there are reasonable arguments for restricting mixed form submissions, for
  example.

  <section>
    <h3 id="categories-active">Active Content</h3>

    <dfn export title="active content|active">Active content</dfn> is content
    which can in some way directly manipulate the resource with which a user
    is interacting. Script and style are the clearest examples: if an attacker
    can manipulate either, she can completely control the activity on a webpage
    and exfiltrate data at will. Active content include the following resource
    types:

    <ul>
      <li>
        Scripts (loaded, for example, via <a element>script</a> elements, as
        well as scripts loaded as Workers and SharedWorkers [[!WORKERS]], or
        ServiceWorkers [[!SERVICEWORKERS]]) [[!ECMA-262]]
      </li>
      <li>Stylesheets [[!CSS21]]</li>
      <li>
        <a>Plugin</a> data (loaded, for example, through
        <a element>applet</a>, <a element>embed</a>, or <a element>object</a>
        elements; or through a <a>plugin document</a> loaded into an
        <a element>iframe</a> or <a>frame</a> element) [[!HTML5]]
      </li>
      <li>SVG Documents [[!SVG2]]</li>
      <li>XSL Transformations [[!XSLT]]</li>
      <li>HTML Imports [[!HTML-IMPORTS]]</li>
      <li>HTML Manifests [[!MANIFEST]]</li>
      <li>Documents rendered in <a element>iframe</a> elements</li>
    </ul>

    These resource types map to the following Fetch <a>request contexts</a>:
    <code>script</code>, <code>worker</code>, <code>sharedworker</code>,
    <code>serviceworker</code>, <code>style</code>, <code>object</code>,
    <code>manifest</code> and <code>child</code>. These contexts are
    <dfn export>active request contexts</dfn>.

    The contents of an <a element>iframe</a> are considered active content
    because same-origin frames can reach up into their <a>parent browsing
    context</a> via script, and even cross-origin frames can initiate
    top-level navigations. User agents MAY decide to treat cross-origin
    frames as <a>passive</a> content if that capability is removed by applying
    a appropriate <a>sandboxing flag set</a> (e.g. one which does not include
    the <a element-attr>allow-top-navigation</a> flag).

    Note: <a element>iframe</a> elements, as currently implemented in user
    agents do come with risks beyond those mentioned above. For example,
    <a href="http://lcamtuf.blogspot.de/2012/05/yes-you-can-have-fun-with-downloads.html">a
    downloaded file's origin is often difficult to pinpoint</a>, HTTP
    authentication prompts are sometimes allowed (after a HTTP 401 response,
    for instance), and modal prompts like <code>window.prompt()</code> can
    confuse users. These risks exist even with secure iframes, but attackers
    can more easily inject malicious code into innocent but insecure iframes.

    Issue: Should form submissions to an insecure origin be considered active
    content? I suspect they should, though I'm not sure we can get away with
    it in a web-compatible way.
  </section>

  <section>
    <h3 id="categories-passive">Passive Content</h3>

    <dfn export title="passive content|passive">Passive content</dfn> includes
    resources which cannot directly interact with or modify other resources on
    a page: images, fonts, audio, and video for example. The risk of rendering a
    manipulated passive resource is significantly lower than executing an
    <a>active</a> resource; passive content can confuse or deceive users, but
    cannot directly manipulate other resources on a page or exfiltrate data.

    <a>Active content</a> is clearly dangerous in a <a>mixed</a> context, and
    must be blocked from executing in those contexts to protect both users and
    site authors, regardless of the risk of breaking insecurely composed
    websites. Passive <a>mixed</a> content is less directly dangerous to
    users: if an attacker manipulates an image resource, the worst case is that
    the attacker-controlled image is displayed to the user rather than the image
    a site's author intended.

    In a perfect world, user agents would be required to block <em>all</em>
    types of <a>mixed content</a>. Unfortunately, there exists a massive amount
    of passive <a>mixed content</a> on the Internet today:
    <a href="http://www.securitee.org/files/mixedinc_isc2013.pdf">according to a
    survey in 2013</a> blocking passive mixed content would break around ~43% of
    secure websites in one way or another. Draconian blocking policies applied to
    passive mixed content are (for the moment) infeasible. User agents must be
    more nuanced in their restrictions.

    With that in mind, we'll split passive content into two categories:
    resources user agents can safely block without breaking the web, and
    resources whose usage in <a>mixed</a> contexts is simply too high to block
    by default.

    Future versions of this specification will update these subcategories with
    the intent of moving towards a world where all <a>mixed</a> content is
    blocked; that is the end goal, but this is the best we can do for now.

    Issue: Should the presence of a form with an <a element-attr>action</a>
    attribute representing an <a><em>a priori</em> insecure origin</a> be
    considered passive mixed content?

    <section>
      <h4 id="categories-passive-optionally-blockable">
        Optionally-blockable Passive Content
      </h4>

      Passive content is
      <dfn export title="optionally blockable passive content|optionally blockable passive|optionally blockable">
      optionally blockable</dfn> when the risk of allowing its usage in a <a>mixed</a>
      context is outweighed by the risk of breaking significant portions of the
      web. This may be because usage of these resource types in <a>mixed</a>
      contexts is sufficiently high, or because the feature is very clearly
      low-risk in and of itself.

      This category includes:

      <ul>
        <li>
          Images loaded via <a element>img</a> or <code>picture</code>

          Note: This includes SVG documents loaded as images.
        </li>
        <li>
          Video loaded via <a element>video</a> and <a element>source</a>
          elements
        </li>
        <li>
          Audio loaded via <a element>audio</a> and <a element>source</a>
          elements
        </li>
        <li>
          <a href="http://www.w3.org/TR/html5/links.html#link-type-prefetch">Prefetched</a>
          content
        </li>
      </ul>

      These resource types map to the following Fetch <a>request contexts</a>:
      <code>image</code>, <code>media</code>, and <code>prefetch</code>. These
      contexts are <dfn export>optionally blockable passive request
      contexts</dfn>.

      Note: The fact that these resource types are on the "optionally blockable"
      list does not mean that they are <em>safe</em>, simply that they're less
      catastrophically dangerous as the resource types on the "active" list.
      For example, images and icons are often the central UI elements in an
      application's interface. If an attacker reversed the "Delete email"
      and "Reply" icons, there would be real impact on users.
    </section>

    <section>
      <h4 id="categories-passive-blockable">Blockable Passive Content</h4>

      Passive content is
      <dfn export title="blockable passive content|blockable passive|blockable">
      blockable</dfn> when the risk of allowing its usage in a <a>mixed</a>
      context outweighs the risk of temporary inconvenience for those site
      authors delivering insecurely composed pages. This may be because usage
      of these features in <a>mixed</a> contexts is sufficiently low, or
      because the content is close to the boundary between <a>active</a> and
      <a>passive</a>.

      This category includes all content that is not <a>optionally blockable</a>
      or <a>active</a>. For example:

      <ul>
        <li>
          Beacon [[!BEACON]]
        </li>
        <li>Custom Filters [[!FILTER-EFFECTS]]</li>
        <li>
          Data (loaded, for example, via XMLHttpRequest [[!XMLHTTPREQUEST]],
          EventSource [[!EVENTSOURCE]], or WebSockets [[!WEBSOCKETS]])
        </li>
        <li>
          <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#hyperlink-auditing">hyperlink auditing pings</a>
        </li>
        <li>
          Resources which are not rendered directly in the browser, but
          downloaded to a user's storage device (either as a result of a
          <a element-attr>download</a> attribute, or
          <code>Content-Disposition</code> headers)
        </li>
        <li>
          Subtitles and captions loaded via <a element>track</a> elements
        </li>
        <li>Web Fonts [[!CSS3-WEBFONTS]]</li>
      </ul>

      <div class="note">
        Note: In particular, this category includes data loaded via
        <code>XMLHttpRequest</code>, <code>EventSource</code>, or
        <code>WebSockets</code>. While these communication mechanism are
        <em>technically</em> passive, developers very often use them to gather
        data that affects program control flow. Consider a missile silo UI
        that grabs JSON to determine whether to reveal the Big Red Launch Button:

        <pre>
          {
            showLaunchButton: false
          }
        </pre>

        Or the ever-popular:

        <pre>
          document.write("&lt;script&gt;" + xhr.responseText + "&lt;/script&gt;");
        </pre>
      </div>

      These resource types map to the following Fetch <a>request contexts</a>:
      <code>connect</code>, <code>download</code>, <code>ping</code>, and
      <code>font</code>. These contexts are <dfn export>blockable passive
      request contexts</dfn>.
    </section>
  </section>
  <section>
    <h3 id="categories-unknown-content">Future Contexts</h3>

    This document exhaustively categorizes the <a>request contexts</a> currently
    defined in the Fetch specification. It is the intention of the Working Group
    that any new content types defined in the future be prevented from loading
    as <a>mixed content</a>. To that end, any <a>request context</a> which is
    not explicitly listed in the preceeding content categories MUST be
    considered an <a>active request context</a> when determining whether or not
    a request should be blocked as mixed content.
  </section>
</section>

<!--
██     ██    ███          ████████  ████████  ███████  ██     ██ ████ ████████  ████████ ██     ██ ████████ ██    ██ ████████  ██████
██     ██   ██ ██         ██     ██ ██       ██     ██ ██     ██  ██  ██     ██ ██       ███   ███ ██       ███   ██    ██    ██    ██
██     ██  ██   ██        ██     ██ ██       ██     ██ ██     ██  ██  ██     ██ ██       ████ ████ ██       ████  ██    ██    ██
██     ██ ██     ██       ████████  ██████   ██     ██ ██     ██  ██  ████████  ██████   ██ ███ ██ ██████   ██ ██ ██    ██     ██████
██     ██ █████████       ██   ██   ██       ██  ██ ██ ██     ██  ██  ██   ██   ██       ██     ██ ██       ██  ████    ██          ██
██     ██ ██     ██       ██    ██  ██       ██    ██  ██     ██  ██  ██    ██  ██       ██     ██ ██       ██   ███    ██    ██    ██
 ███████  ██     ██       ██     ██ ████████  █████ ██  ███████  ████ ██     ██ ████████ ██     ██ ████████ ██    ██    ██     ██████
-->
<section>
  <h2 id="requirements">User Agent Requirements</h2>

  <section>
    <h3 id="requirements-fetching">Resource Fetching</h3>

    User agents SHOULD reject <a>weakly TLS-protected</a> resources entirely
    by failing the TLS handshake, or by requiring explicit user acceptance
    of the risk (for instance, presenting the user with a confirmation screen
    she must click through).

    If a <a>global environment</a> is a <a>secure context</a>, then user agents
    MUST adhere to the following requirements when <a>fetching</a> resources in
    response to its requests (including not only requests for a
    <a interface>Document</a>'s subresources, but also requests made from
    Workers, SharedWorkers, ServiceWorkers and so on):

    <ol>
      <li>
        <a>Requests</a> for <a>active</a> resources and <a>blockable passive</a>
        resources from an <a><em>a priori</em> insecure origin</a> MUST not
        generate network traffic, and MUST instead return a synthetically
        generated <a>network error</a> response.
      </li>

      <li>
        <a>Responses</a> to <a>requests</a> for <a>active</a> resources and
        <a>blockable passive</a> resources from an <a>insecure origin</a> MUST
        not be delivered to the requesting <a>global environment</a>, but
        instead MUST return a synthetically generated <a>network error</a>
        response.
      </li>

      <li>
        <a>Requests</a> for <a>optionally blockable passive</a> resources which
        are <a>mixed content</a> SHOULD be treated as <a>active</a> (and
        therefore returned as a <a>network error</a> as described above).

        Note: For instance, a user agent could interpret the presence of a
        <code>Strict-Transport-Security</code> header field as forcing all
        content into the <a>active</a> category. [[RFC6797]]
      </li>

      <li>
        <a>Requests</a> for <a>optionally blockable passive</a> resources which
        are <a>mixed content</a>, but which are <strong>not</strong> treated
        as <a>active content</a> MAY be modified to reduce the risk to users.
        For example, cookies and other authentication tokens could be stripped
        from the requests, or the user agent could automatically change the
        protocol of the requested URL to <code>HTTPS</code> in certain cases.
      </li>
    </ol>

    If a <a>global environment</a>'s origin is a <a>public origin</a>, then user
    agents MUST adhere to the following requirements when <a>fetching</a>
    resources in response to the environment's requests:

    <ol>
      <li>
        <a>Requests</a> to <a>private origins</a> from <a>public origins</a>
        MUST not generate network traffic (including traffic on loopback
        interfaces), and MUST instead return a synthetically generated
        <a>network error</a> response.
      </li>
    </ol>

    The <a section href="#fetch-integration"></a> and
    <a section href="#algorithms"></a> sections detail how these fetching
    requirements could be implemented.
  </section>

  <section>
    <h3 id="requirements-script">Script APIs</h3>

    If a <a>global environment</a> is a <a>secure context</a>, then user agents
    MUST adhere to the following requirements when executing the following APIs:

    <ol>
      <li>When processing XMLHttpRequest's
      <a href="http://www.w3.org/TR/XMLHttpRequest2/#the-open-method"><code>open()</code>
      method</a>, throw a <code>SecurityError</code> exception and terminate the
      method's execution if the <var>request URL</var> provided points to an
      <a><em>a priori</em> insecure origin</a>. [[!XMLHTTPREQUEST]]</li>

      <li>When processing EventSource's
      <a href="http://www.w3.org/TR/eventsource/#the-eventsource-interface">constructor</a>,
      throw a <code>SecurityError</code> exception and terminate the constructor's
      execution if the <var>url</var> provided points to an <a><em>a priori</em>
      insecure origin</a>. [[!EVENTSOURCE]]</li>

      <li>When processing WebSocket's
      <a href="http://www.w3.org/TR/websockets/#the-websocket-interface">constructor</a>,
      throw a <code>SecurityError</code> exception and terminate the constructor's
      execution if the <var>url</var> provided points to an <a><em>a priori</em>
      insecure origin</a>. [[!WEBSOCKETS]]</li>
    </ol>
  </section>

  <section>
    <h3 id="requirements-ux">UI Requirements</h3>

    If a <a>request</a> for <a>optionally blockable passive</a> resources
    which are <a>mixed content</a> is <strong>not</strong> treated as <a>active
    content</a> (per requirement #3 above), then the user agent MUST NOT provide
    the user with a visible indication that the <a>top-level browsing
    context</a> which loaded that resource is secure (for instance, via a green
    lock icon). The user agent SHOULD instead display a visible indication that
    <a>mixed content</a> is present.

    This requirement explicitly includes any visible indication of the
    <a>top-level browsing context</a>'s
    <a href="https://cabforum.org/about-ev-ssl/">EV status</a>. [[!CAB]]
  </section>

  <section>
    <h3 id="requirements-user-controls">User Controls</h3>

    User agents MAY offer users the ability to directly decide whether or not to
    treat <strong>all</strong> <a>mixed content</a> as <a>active</a> (meaning
    that even <a>optionally blockable passive content</a> would be blocked in a
    mixed context).

    Note: It is <em>strongly recommended</em> that users take advantage of such
    an option if provided.

    User agents MAY offer users the ability to override its decision to block
    <a>blockable passive</a> mixed content on a particular page.

    User agents MAY also offer users the ability to override its decision to
    block <a>active</a> mixed content on a page.

    Note: Practically, user agents probably can't get away with not offering
    such a back door. That said, allowing active mixed content is in
    particular a very dangerous option, and user agents
    <a href="http://tools.ietf.org/html/rfc6919#section-3">REALLY SHOULD
    NOT</a> present such a choice to users without careful consideration and
    communication of the risk involved.
  </section>
</section>

<!--
   ███    ██        ██████    ███████  ████████  ████ ████████ ██     ██ ██     ██  ██████
  ██ ██   ██       ██    ██  ██     ██ ██     ██  ██     ██    ██     ██ ███   ███ ██    ██
 ██   ██  ██       ██        ██     ██ ██     ██  ██     ██    ██     ██ ████ ████ ██
██     ██ ██       ██   ████ ██     ██ ████████   ██     ██    █████████ ██ ███ ██  ██████
█████████ ██       ██    ██  ██     ██ ██   ██    ██     ██    ██     ██ ██     ██       ██
██     ██ ██       ██    ██  ██     ██ ██    ██   ██     ██    ██     ██ ██     ██ ██    ██
██     ██ ████████  ██████    ███████  ██     ██ ████    ██    ██     ██ ██     ██  ██████
-->
<section>
  <h2 id="algorithms">Algorithms</h2>

  <section>
    <h3 id="categorize-environment">
      Is <var>environment</var> a secure context?
    </h3>

    Given a <a>JavaScript global environment</a> <var>environment</var>, the
    user agent determines whether <var>environment</var> is a
    <dfn export>secure context</dfn> via the following algorithm, which returns
    <strong>true</strong> if <var>environment</var> is a secure context, and
    <strong>false</strong> otherwise.

    <ol>
      <li>
        If <var>environment</var> is <a>TLS-protected</a>, return
        <strong>true</strong>.
      </li>
      <li>
        If <var>environment</var> is a <a>nested browsing context</a>, then:

        <ol>
          <li>Let <var>ancestorList</var> be the list of all
          <a>ancestors</a> of <var>environment</var>'s <a>browsing
          context</a>.</li>

          <li>
            For each <var>ancestorContext</var> in <var>ancestorList</var>:

            <ol>
              <li>Let <var>ancestorEnvironment</var> be the <a>JavaScript
              global environment</a> associated with
              <var>ancestorContext</var></li>

              <li>If <var>ancestorEnvironment</var> is <a>TLS-protected</a>,
              return <strong>true</strong>.</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>Return <strong>false</strong>.</li>
    </ol>

    <div class="note">
      If a document is a <a>nested browsing context</a>, user agents need to
      check not only the document itself, but also the <a>top-level browsing
      context</a> in which the document is nested, as that is the context
      which controls the user's expectations regarding the security status of
      the resource she's loaded. For example:

      <div class="example">
        <code>http://a.com</code> loads <code>http://evil.com</code>. The
        insecure request will be allowed, as <code>a.com</code> was not loaded
        over a secure connection.
      </div>

      <div class="example">
        <code>https://a.com</code> loads <code>http://evil.com</code>. The
        insecure request will be blocked, as <code>a.com</code> was loaded over
        a secure connection.
      </div>

      <div class="example">
        <code>http://a.com</code> frames <code>https://b.com</code>, which
        loads <code>http://evil.com</code>. In this case, the insecure request
        to <code>evil.com</code> will be blocked, as <code>b.com</code> was
        loaded over a secure connection, even though <code>a.com</code> was not.
      </div>

      <div class="example">
        <code>https://a.com</code> frames a <code>data:</code> URL, which loads
        <code>http://evil.com</code>. In this case, the insecure request to
        <code>evil.com</code> will be blocked, as <code>a.com</code> was loaded
        over a secure connection, even though the framed data URL was not.
      </div>
    </div>
  </section>

  <section>
    <h3 id="should-block-fetch">
      Should fetching <var>request</var> be blocked as mixed content?
    </h3>

    Note: The Fetch specification hooks into this algorithm to determine whether
    a request should be entirely blocked (e.g. because the request would be used
    as <a>active content</a>, and we can <em>assume</em> that it won't be
    loaded over a secure connection).

    Given a <a>request</a> <var>request</var>, a user agent determines
    whether the <a>Request</a> <var>request</var>  should proceed or not via the
    following algorithm:

    <ol>
      <li>
        Let <var>context</var> be <var>request</var>'s <code>context</code>.
      </li>
      <li>
        Let <var>client</var> be <var>request</var>'s <code>client</code>.
      </li>
      <li>
        Let <var>environment</var> be the <a>JavaScript global environment</a>
        with which <var>client</var> is associated.
      </li>
      <li>
        Let <var>origin</var> be the <a>origin</a> of <var>request</var>'s
        <strong>URL</strong>.
      </li>
      <li>
        If <var>origin</var> is a <a>private origin</a>, and
        <var>environment</var>'s <a>origin</a> is a <a>public origin</a>,
        return <strong>blocked</strong>.
      </li>
      <li>
        If <var>environment</var> is not a <a>secure context</a>, return
        <strong>allowed</strong>.
      </li>
      <li>
        If <var>origin</var> is <a><em>a priori</em> insecure</a>:

        <ol>
          <li>
            If <var>context</var> is an <a>active request context</a> or
            <a>blockable passive request context</a>, return
            <strong>blocked</strong>.
          </li>
          <li>
            If the user agent is configured to block <a>optionally blockable
            passive</a> mixed content, return <strong>blocked</strong>.
          </li>
        </ol>
      </li>
      <li>
        Otherwise, <var>origin</var> is <a>potentially secure</a>, so
        return <strong>allowed</strong>.
      </li>
    </ol>
  </section>

  <section>
    <h3 id="should-block-response">
      Should <var>response</var> to <var>request</var> be blocked as mixed
      content?
    </h3>

    Note: <a href="#should-block-fetch">If a request proceeds</a>, we still
    might want to block the response based on the state of the connection
    that generated the response (e.g. because the response would be used as
    <a>active content</a>, but the server is <a>insecure</a>). This algorithm
    is used to make that determination.

    Given a <a>request</a> <var>request</var> and <a>response</a>
    <var>response</var>, the user agent determines what response should be
    returned via the following algorithm:

    <ol>
      <li>
        Let <var>client</var> be <var>request</var>'s <code>client</code>.
      </li>
      <li>
        Let <var>environment</var> be the <a>JavaScript global environment</a>
        with which <var>client</var> is associated.
      </li>
      <li>
        If <var>environment</var> is not a <a>secure context</a>, return
        <strong>allowed</strong>.
      </li>
      <li>
        Let <var>context</var> be the <a>request context</a> of
        <var>request</var>.
      </li>
      <li>
        If <var>context</var> is an <a>active request context</a> or
        <a>blockable passive request context</a>, or the user agent is
        configured to block <a>optionally blockable passive</a> mixed content:

        <ol>
          <li>
            If the response is not <a>TLS-protected</a>, return
            <strong>blocked</strong>.

            Issue: This is intended to cover cases in which a ServiceWorker
            responds to a request with an insecure resource. It's not clear
            that this is the correct place to do that, however, as the
            integration with Fetch isn't fully specified. It's also not really
            clear what "insecure" should mean in a ServiceWorker context. We
            accept <code>blob</code> resources, for instance: should we accept
            responses synthesized by the service worker?
          </li>
          <li>
            If the response is only <a>weakly TLS-protected</a>, return
            <strong>blocked</strong>.

            Note: If a user agent is configured to reject <a>weakly
            TLS-protected</a> resources, we'll never hit this condition, as
            <a href="http://fetch.spec.whatwg.org/#fetching">step 6 of the Fetch
            algorithm</a> would have returned a network error.
          </li>
          <li>
            If the response's TLS-protection is <a>deprecated</a>, return
            <strong>blocked</strong>.

            Note: This covers cases in which the TLS handshake succeeds, and the
            resource exceeds the definition of <a>weakly TLS-protected</a>, but
            the user agent chooses to hold it to a higher standard. The definition
            of <a>deprecated TLS-protection</a> has some examples of these kinds
            of scenarios.
          </li>
        </ol>
      </li>
      <li>Return <strong>allowed</strong>.</li>
    </ol>
  </section>
</section>

<!--
████████ ████████ ████████  ██████  ██     ██
██       ██          ██    ██    ██ ██     ██
██       ██          ██    ██       ██     ██
██████   ██████      ██    ██       █████████
██       ██          ██    ██       ██     ██
██       ██          ██    ██    ██ ██     ██
██       ████████    ██     ██████  ██     ██
-->
<section>
  <h2 id="fetch-integration">Integration with Fetch</h2>

  When fetching resources, the mixed content checks described in the algorithms
  above should be inserted at the top of the Fetch algorithm to block network
  traffic to <a><em>a priori</em> insecure origins</a> and <a>private
  origins</a>, and at the bottom of the algorithm, to block responses from
  <a>insecure origins</a>.

  Fetch calls the algorithm defined in
  <a section href="#should-block-fetch"></a> during
  <a href="http://fetch.spec.whatwg.org/#fetching">Step 4 of the 'Fetching'
  algorithm</a>. [[!FETCH]]

  Note: Hooking into Fetch here ensures that we catch not only the initial
  request, but all redirects as well. That is certainly the intent.

  Further, Fetch calls the algorithm defined in
  <a section href="#should-block-response"></a> during
  <a href="http://fetch.spec.whatwg.org/#fetching">Step 7 of the 'Fetching'
  algorithm</a>. [[!FETCH]]

  Note: This hook is necessary to detect resources modified or
  synthesized by a ServiceWorker, as well as to determine whether a
  resource is <a>insecure</a> once the TLS-handshake has finished. See
  steps 4.1 and 4.2 of the <a section href="#should-block-response"></a>
  algorithm for detail.
</section>

<!--
██      ██ ████████ ████████   ██████   ███████   ██████  ██    ██ ████████ ████████  ██████
██  ██  ██ ██       ██     ██ ██    ██ ██     ██ ██    ██ ██   ██  ██          ██    ██    ██
██  ██  ██ ██       ██     ██ ██       ██     ██ ██       ██  ██   ██          ██    ██
██  ██  ██ ██████   ████████   ██████  ██     ██ ██       █████    ██████      ██     ██████
██  ██  ██ ██       ██     ██       ██ ██     ██ ██       ██  ██   ██          ██          ██
██  ██  ██ ██       ██     ██ ██    ██ ██     ██ ██    ██ ██   ██  ██          ██    ██    ██
 ███  ███  ████████ ████████   ██████   ███████   ██████  ██    ██ ████████    ██     ██████
-->
<section>
  <h2 id="websockets-integration">Modifications to WebSockets</h2>
  
  The <a href="http://www.w3.org/TR/2012/CR-websockets-20120920/#the-websocket-interface"><code>WebSocket()</code>
  constructor algorithm</a> [[!WEBSOCKETS]] is modified as follows:

  <ul>
    <li>
      Replace Step 2 with the following steps:

      <ol>
        <li>
          If <var>secure</var> is <strong>false</strong>, but the <a>JavaScript
          global environment</a> which the <var>entry script</var> is associated
          with is a <a>secure context</a>, then throw a
          <code>SecurityError</code> exception.
        </li>
        <li>
          If the <a>origin</a> of the <a>JavaScript global environment</a> with
          which the <var>entry script</var> is associated is a <a>public
          origin</a>, and the <a>origin</a> of the <var>url</var> argument is a
          <a>private origin</a>, then throw a <code>SecurityError</code>
          exception.
        </li>
      </ol>
    </li>
  </ol>

  The <a href="http://tools.ietf.org/html/rfc6455#section-4.1">Establish a
  WebSocket Connection algorithm</a> is modified as follows:

  <ol>
    <li>
      After step 5, perform the following step:

      <ol>
        <li>
          If secure is <strong>true</strong>, and the TLS handshake performed
          in step 5 results in a <a>weakly TLS-protected</a> connection, or the
          TLS-protection is <a>deprecated</a>,then the client MUST
          <a href="http://tools.ietf.org/html/rfc6455#section-7.1.7">Fail the
          WebSocket Connection</a> and abort the connection.
        </li>
      </ol>
    </li>
  </ul>
</section>

<!--
   ███     ██████  ██    ██ ██    ██  ███████  ██      ██ ██       ████████ ████████   ██████   ████████ ██     ██ ████████ ██    ██ ████████  ██████
  ██ ██   ██    ██ ██   ██  ███   ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ███   ███ ██       ███   ██    ██    ██    ██
 ██   ██  ██       ██  ██   ████  ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██        ██       ████ ████ ██       ████  ██    ██    ██
██     ██ ██       █████    ██ ██ ██ ██     ██ ██  ██  ██ ██       ██████   ██     ██ ██   ████ ██████   ██ ███ ██ ██████   ██ ██ ██    ██     ██████
█████████ ██       ██  ██   ██  ████ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ██     ██ ██       ██  ████    ██          ██
██     ██ ██    ██ ██   ██  ██   ███ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ██     ██ ██       ██   ███    ██    ██    ██
██     ██  ██████  ██    ██ ██    ██  ███████   ███  ███  ████████ ████████ ████████   ██████   ████████ ██     ██ ████████ ██    ██    ██     ██████
-->
<section>
  <h2 id="acknowledgements">Acknowledgements</h2>
  
  In addition to the wonderful feedback gathered from the WebAppSec WG, the
  Chrome security team was invaluable in preparing this specification. In
  particular, Chris Palmer, Chris Evans, Ryan Sleevi, Michal Zalewski, Ken
  Buchanan, and Tom Sepez gave lots of early feedback. Anne van Kesteren
  explained Fetch and helped define the interface to this specification.
</section>
