<h1>Mixed Content</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec/specs/mixedcontent/
Shortname: MIX
Level: 1
Editor: Mike West, Google Inc., mkwst@google.com
Group: webappsec
Abstract: This specification describes how and why user agents disallow rendering and execution of content loaded over unencrypted or unauthenticated connections in the context of an encrypted and authenticated document.
Link Defaults: HTML5 (dfn) plugin / nested browsing contexts / top-level browsing context
Link Defaults: HTML5 (interface) document
</pre>

<!-- Big Text: Intro -->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  When a user successfully loads a document from example.com over a secure
  channel (HTTPS, for example), the user agent is able to make two assertions
  critical to the user's security and privacy:

  <ul>
    <li>
      The user's communications with example.com cannot be trivially
      eavesdropped upon or manipulated by middlemen, because the requests she
      makes and the responses she receives are <strong>encrypted</strong>.
    </li>
    <li>
      The user is communicating with a server that is allowed to claim to be
      <code>example.com</code>, and not one of the many, many servers through
      which her request has hopped. The connection can be
      <strong>authenticated</strong>.
    </li>
  </ul>

  Together, these assertions give the user a reasonable expectation of both
  privacy and data integrity in her communications. She can be confident that
  <code>example.com</code> is the only entity that can read and respond to her
  requests, and that the bits she's receiving are indeed those that
  <code>example.com</code> actually sent.

  The strength of these assertions is substantially weakened, however, when
  the encrypted and authenticated document requests subresources (scripts,
  images, etc) over an insecure channel. Those resource requests result in a
  document whose status is mixed, as unsecured requests are wide open for
  man-in-the-middle attacks. This scenario is unfortunately quite common.

  This specification details how user agents can mitigate this risk to users'
  security and privacy by limiting a document's ability to inadvertently
  communicate in the clear. At worst, resource requests for unsecured content
  should downgrade any visible security indicators presented to the user (e.g.
  no "green lock"). At best, these requests should be blocked entirely.
</section>

<!-- Big Text: Definitions -->
<section>
  <h2 id="key-concepts">Key Concepts and Terminology</h2>

  <!-- TODO: Drop the <dfn>s here once I can autolink to the RFCs. -->
  The term <dfn>origin</dfn> is defined in the Origin specification.
  [[!RFC6454]]

  The term <dfn>URI</dfn> is defined in the URI specification. [[!URI]]

  The term <dfn>resource representation</dfn> is defined in the HTTP 1.1
  specification. [[!HTTP11]]

  A <a>plugin</a> is defined in the HTML5 specification. [[!HTML5]]

  The terms <dfn>TLS-protected</dfn> and <dfn>weakly TLS-protected</dfn> are
  defined in [[!WSC-UI]]

  The term <dfn>globally unique identifier</dfn> is defined in section 4 of
  the Origin specification. Note that URLs that do not use hierarchical
  elements as naming authorities have origins which are globally unique
  identifiers. [[!RFC6454]]

  The terms <dfn>request</dfn>, <dfn title="request client|client">client</dfn>
  and <dfn title="request context|context">context</dfn> are defined in
  <a href="http://fetch.spec.whatwg.org/#requests">Section 2.2</a> of the Fetch
  specification. [[!FETCH]]
</section>

<section>
  <h2 id="categories">Categories of Content</h2>

  In an ideal world, user agents would block all requests for unsecured
  content from within a secured context. This would solve the problem of mixed
  content completely. It would also,
  <a href="http://www.securitee.org/files/mixedinc_isc2013.pdf">according to one 2013 survey</a>,
  break ~43% of websites in one way or another. User agents need to distinguish,
  therefore, between content that MUST be blocked, and content that may be
  rendered despite its dubious origin.

  Categories of content are defined informally directly below, and formally in
  the <a section href="#categorize-content"></a> algorithm.

  <section>
    <h3 id="categories-active">Active Content</h3>

    <dfn export title="active content|active">Active content</dfn> is content
    which poses a distinct threat to the user viewing a website. Scripts are
    the best example: if an active network attacker can manipulate the content
    of a script, she can completely control the activity on a webpage, removing
    any protection that encryption may have offered. Examples of active content
    include the following resource types:

    <ul>
      <li>Scripts, including scripts loaded as Workers, SharedWorkers, and
      ServiceWorkers</li>
      <li>Stylesheets</li>
      <li>Web Fonts [[!CSS3-WEBFONTS]]</li>
      <li><a>Plugins</a></li>
      <li>Data loaded via XMLHttpRequest [[!XMLHTTPREQUEST]]</li>
      <li>EventSource targets [[!EVENTSOURCE]]</li>
      <li>WebSocket targets [[!WEBSOCKETS]]</li>
      <li>Documents rendered in <a element>iframe</a> elements</li>
      <li>HTML Imports [[!HTML-IMPORTS]]</li>
      <li>HTML Manifests [[!MANIFEST]]</li>
    </ul>

    Note: Plugins themselves are certainly considered active content, but
    requests made by plugins are not. It's impossible for the user agent to
    determine how data loaded by a plugin will be used (and, as a practical
    matter, plugins often bypass the user agent's network stack).

    Issue: Is this list exhaustive enough, or are there examples we should add?
  </section>

  <section>
    <h3 id="categories-passive">Passive Content</h3>
    
    <dfn export title="passive content|passive">Passive content</dfn> covers
    resources which does not fall into one of the above categories: images,
    audio, video, and so on. This content cannot be used directly to attack
    users; the risk of rendering it is significantly lower than the risk of
    executing or interpreting <a>active content</a>.
  </section>
</section>

<section>
  <h2 id="algorithms">Algorithms</h2>

  <section>
    <h3 id="categorize-content">Is <var>context</var> active or passive?</h3>

    Fetch defines a number of <a>request contexts</a> which reflect how a
    request will be rendered or executed by a document. Some contexts which can
    manipulate the page are considered <a>active</a>, others <a>passive</a>.
   
    Given a <a>request context</a> <var>context</a>, the user agent can
    determine whether the result will be used as <a>active content</a> via the
    following algorithm:

    <ol>
      <li>If <var>context</var> is one of <code>form</code>, <code>image</code>,
      <code>media</code>, <code>navigate</code>, or <code>popup</code>, return
      <code><strong>passive</strong></code>.</li>

      <li>Return <code><strong>active</strong></code>.</li>
    </ol>
  </section>

  <section>
    <h3 id="categorize-document">
      Is <var>document</var> a secure browsing context?
    </h3>

    User agents MUST ensure that nested browsing contexts are checked against
    the top-level parent context, as that is the context which controls the
    user's expectations regarding the security status of the resource she's
    loaded. The following nested-framing scenarios are interesting: 

    <ol>
      <li><code>http://a.com</code> frames <code>https://b.com</code>, which
      loads <code>http://evil.com</code>. In this case, the unsecured request
      to <code>evil.com</code> MUST be blocked, as <code>b.com</code> was
      loaded over a secure connection.</li>

      <li><code>https://a.com</code> frames <code>http://b.com</code>, which
      loads <code>http://evil.com</code>. In this case, the unsecured request
      to <code>evil.com</code> MUST not be allowed, as <code>a.com</code> was
      loaded in a secure context (and, hopefully <em>cannot</em> happen, as
      the <code>b.com</code> frame MUST not be loaded over an insecure channel
      in the first place).</li>
    </ol>

    Given a <a interface>Document</a> <var>document</var>, the user agent can
    determine if <var>document</var> is a <dfn>secure browsing context</dfn>
    via the following algorithm, which returns <strong>true</strong> if the
    <a interface>Document</a> is a secure browsing context, and
    <strong>false</strong> otherwise. 

    <ol>
      <li>
        If <var>document</var> is <a>TLS-protected</a>, return
        <strong>true</strong>.
      </li>
      <li>
        If the scheme component of <var>document</var>'s URL is of a type
        designating a <a>globally unique identifier</a> (such as "blob" or
        "data"), return <strong>true</strong>.
      </li>
      <li>
        If <var>document</var> is a <a>nested browsing context</a>:
        
        <ol>
          <li>
            If the <a>top-level browsing context</a> is a <a>secure
            browsing context</a>, return <strong>true</strong>.
          </li>
        </ol>
      </li>
      
      <li>Return <strong>false</strong>.</li>
    </ol>
  </section>

  <section>
    <h3 id="should-block-fetch">
      Should a fetch of <var>url</var> as <var>context</var> for
      <var>client</var> be blocked as mixed content?
    </h3>

    User agents should entirely block requests to <a>active</a> mixed content;
    the Fetch specification will hook into this algorithm to determine whether a
    request should be entirely blocked (e.g. because the request would be used
    as <a>active content</a>, and we know <em>a priori</em> that it won't be
    loaded over a secure connection).

    Given a request's URL <var>url</var>, <a>request context</a>
    <var>context</var>, and <a>request client</a> <var>client</var>, a user
    agent can determine whether the request should proceed or not via the
    following algorithm

    <ol>
      <li>
        Let <var>document</var> be the <a interface>Document</a> with which
        <var>client</var> is associated.
      </li>
      <li>
        If <var>document</var> is not a <a>secure browsing context</a>, return
        <strong>allowed</strong>.
      </li>
      <li>
        If the scheme component of <var>url</var> is "HTTPS", return
        <strong>allowed</strong>.
      </li>
      <li>
        If the scheme component of <var>url</var> is of a type designating a
        <a>globally unique identifier</a>, (such as "blob" or "data") then
        return <strong>allowed</strong>.
      </li>
      <li>
        If the result of the <a section href="#categorize-content"></a>
        algorithm is <strong>active</strong>, or if the user agent is
        configured to block <a>passive</a> mixed content, return
        <strong>blocked</strong>.
      </li>
      <li>
        Return <strong>allowed</strong>.
      </li>
    </ol>

    Issue: Chrome doesn't currently process resources loaded via
    <code>&lt;link rel="subresource" ...&gt;</code> or
    <code>Link: ...; prefetch</code>. Perhaps we should?
  </section>

  <section>
    <h3 id="should-block-response">
      Should <var>response</var> for <var>client</var> be blocked as mixed
      content?
    </h3>

    <a href="#should-block-fetch">If a request proceeds</a>, we still might want
    to block the response based on the state of the connection that generated
    the response (e.g. because the response would be used as <a>active
    content</a>, but the server is unauthenticated).

    Given a <a>response</a> <var>response</var>, and <a>request client</a>
    <var>client</var> (as defined by Section 2.2 of Fetch), we can determine what response should be returned via the following algorithm: 

    Let document be the document with which client is associated.
    If document is not secure, return allowed.
    Let context be the context of the request to which response responds.
    If context is active, or the user agent is configured to block passive mixed content:
    If the response is weakly TLS-protected, return false.
    If the scheme component of response's URL is "HTTP", return false.
    TODO: Should we talk about things like mixed-pinning?
    Return true.
  </section>
